# OpenGL ES

## 简介

**OpenGL ES (OpenGL for Embedded Systems)** 是以⼿持和嵌⼊式为目标的⾼级**3D**图形应用程序编程接⼝**(API). OpenGL ES **是⽬前智能手机中占据统治地位的图形 **API**。⽀持的平台: iOS, Andriod , BlackBerry ,bada ,Linux ,Windows。

OpenGL ES 开放式图形库(OpenGL)⽤于可视化的二维和三维数据。它是一个多功能开放标准图形库，支持2D和3D数字内容创建，机械和建筑设计，虚拟原型设计，飞行模拟，视频游戏等应用程序。您可以使用OpenGL配置3D图形管道并向其提交数据。顶点被变换和点亮，组合成图元，并光栅化以创建2D图像。OpenGL旨在将函数调用转换为可以发送到底层图形硬件的图形命令。由于此底层硬件专用于处理图形命令，因此OpenGL绘图通常非常快。

OpenGL for Embedded Systems(OpenGL ES)是OpenGL的简化版本，它消除了冗余功能，提供了一个既易于学习⼜更易于在移动图形硬件中实现的库。

下图展示了 OpenGL ES 3.0 图形管线，顶点着色器和片段着色器为可编程阶段。

<img src="./img/08-001 OpenGL ES 3.0 图形管线.png" style="zoom:50%;" />

#### 顶点着色器

顶点着色器实现了顶点操作的通用可编程方法。

顶点着色器的输入包括：

- 着色器程序 —— 描述顶点上执行操作的顶点着色器程序源代码或者可执行文件。
- 顶点着色器输入（属性）—— 用顶点数组提供的每个顶点的数据。
- 统一变量（uniform）—— 顶点/片段/片元着色器使用的不变数据。
- 采样器 —— 代表顶点着色器使用纹理的特殊统一变量类型。

顶点着色器可以用于通过矩阵变换位置、计算照明公式来生成逐顶点颜色以及生成或者变换纹理坐标等基于顶点的传统操作。此外，因为顶点着色器由应用程序规定，所以它可以用于执行自定义计算，实施新的变换、照明或者较传统的固定功能管线所不允许的基于顶点的效果。

顶点着色器 业务：

- 矩阵变换位置
- 计算光照公式生成逐顶点颜色
- 生成/变换纹理坐标

**总结：**它可以用于执⾏自定义计算，实施新的变换，照明或者传统的固定功能所不允许的基于顶点的效果。

**顶点着色代码案例：**

```c
attribute vec4 position;
attribute vec2 textCoordinate; 
uniform mat4 rotateMatrix; 
varying lowp vec2 varyTextCoord;
void main() {
	varyTextCoord = textCoordinate; vec4 vPos = position;
	vPos = vPos * rotateMatrix; gl_Position = vPos;
}
```

#### 图元装配

顶点着色器之后，下一阶段是图元装配。

图元（Primitive）：点，线，三角形等。

图元装配：将顶点数据计算成一个个图元。在这个阶段会执行裁剪、透视分割和 Viewport 变换操作。

图元类型和顶点所确定将被渲染的单独图元。对于每个单独图元及其对应的顶点，图元装配阶段执⾏的操作包括：将顶点着⾊器的输出值执⾏裁剪、透视分割、视口变换后进⼊光栅化阶段。

#### 光栅化

在这个阶段绘制对应的图元(点/线/三⻆角形)。光栅化就是将图元转化成⼀组⼆维⽚段的过程。而这些转化的⽚段将由⽚元着⾊器处理。这些⼆维⽚段就是屏幕上可绘制的像素。

<img src="./img/08-002 OpenGL ES 3.0 光栅化阶段.png" style="zoom:50%;" />

#### 片元着色器

顶点着色器的输入包括：

- 着色器程序 —— 描述片段上执行操作的片段着色器程序源代码或者可执行文件。
- 输入变量 —— 光栅化单元用茶质为每个片段生成的顶点着色器输出。
- 统一变量 —— 顶点/片段/片元着色器使用的不变数据。
- 采样器 —— 代表片段着色器使用纹理的特殊统一变量类型。

顶点着色器 业务：

- 计算颜色
- 获取纹理值
- 往像素点中填充颜色值（纹理值/颜色值）

**总结：**它可以⽤于图⽚/视频/图形中每个像素的颜色填充（比如给视频添加滤镜，实际 上就是将视频中每个图片的像素点颜色填充进行修改）。

**片元着色代码案例：**

```c
varying lowp vec2 varyTextCoord; 
uniform sampler2D colorMap; 
void main() {
  gl_FragColor = texture2D(colorMap, varyTextCoord); 
}
```

#### 逐片段操作

<img src="/Users/caianfang/Desktop/gitdir/note/OpenGL/img/08-003 OpenGL ES 3.0 逐片段操作.png" alt="08-003 OpenGL ES 3.0 逐片段操作" style="zoom:50%;" />

- **像素归属测试**：确定帧缓存区中位置**(Xw,Yw)**的像素⽬前是不是归属于 **OpenGL ES** 所有。例如，如果⼀个显示 **OpenGL ES** 帧缓存区 **View** 被另外⼀个 **View** 所遮蔽，则窗⼝系统可以确定被遮蔽的像素不属于**OpenGL ES**上下文，从⽽不全显示这些像素。⽽像素归属测试是 **OpenGL ES ** 的⼀部分，它不由开发者开⼈为控制，⽽是由 **OpenGL ES** 内部进⾏。

- **裁剪测试**：裁剪测试确定 **(Xw,Yw)** 是否位于作为 **OpenGL ES** 状态的⼀部分裁剪矩形范围内。如果该⽚段位于裁剪区域之外，则被抛弃。

- **深度测试**：输⼊片段的深度值进步比较，确定⽚段是否拒绝测试。

- **混合**：混合将新⽣成的⽚段颜⾊与保存在帧缓存的位置的颜⾊值组合起来。

- **抖动**：抖动可⽤于最⼩化因为使⽤有限精度在帧缓存区中保存颜⾊值而产生的伪像。

#### EGL（Embedded Graphics Library）

- **OpenGL ES** 命令需要渲染上下文和绘制表⾯才能完成图形图像的绘制。

- **渲染上下⽂文**：存储相关 **OpenGL ES** 状态。

- **绘制表面**：是⽤于绘制图元的表⾯，它指定渲染所需要的缓存区类型，例如颜色缓冲区，深度缓冲区和模板缓存区。

- **OpenGL ES API** 并没有提供如何创建渲染上下⽂或者上下文如何连接到原⽣窗⼝系统。**EGL** 是 **Khronos** 渲染 **API**（如 **OpenGL ES**）和原⽣窗口系统之间的接口。唯一支持 **OpenGL ES** 却不支持 **EGL** 的平台是 **iOS. Apple** 提供自己的 **EGL API** 的 **iOS**实现，称为 **EAGL**。

- 因为每个窗口系统都有不同的定义，所以 **EGL** 提供基本的不透明类型 — **EGLDisplay**，这 个类型封装了所有系统相关性，用于和原⽣窗口系统接口。

由于 **OpenGL ES** 是基于 **C** 的 **API**，因此它非常便携且受到⼴泛支持。作为 **C API**，它与 **Objective-C Cocoa Touch** 应用程序⽆缝集成。**OpenGL ES** 规范没有定义窗口层; 相反，托管操作系统必须提供函数来创建⼀个接受命令的 **OpenGL ES** 渲染上下文和一个帧缓冲区，其中写⼊任何绘图命令的结果。在 **iOS** 上使用 **OpenGL ES** 需要使用 **iOS** 类来设置和呈现绘图表面，并使⽤平台中立的 **API** 来呈现其内容。


